---
layout: post
categories: [개발독서, 켄트벡의 구현패턴]
tags: [켄트벡, 구현패턴]
---
- 컬렉션의 개념은 여러 가지 메타포를 혼합한 것

  ~~→ 그래서 메타포가 뭔데..~~

- 프로그래밍에 있어 가장 근본적인 변형인 몇 개의 데이터를 사용하느냐를 표현한다는 점에서 중요함

### 메타포

- 컬렉션에는 여러 종류의 메타포가 녹아 있음
  - 여러 값을 가진 변수

  → 컬렉션이 어떤 객체냐 하는 것이 중요한 게 아니고, 컬렉션이 가리키는 객체가 어떤 것이냐 하는 것이냐가 중요한 것

- 자바의 경우 컬렉션을 별도의 객체로 취급하므로 여러 값을 가진 변수라는 정체성이 희미해짐

~~→ 그래서 메타포가 뭐냐고..~~

### 이슈

- 원칙적으로 프로그램을 작성할 때는 가급적 정확하게 작성해야 함
- 컬렉션을 사용할 때는
  1. 인터페이스를 사용해서 선언하고
  2. 가장 구체적인 구현 클래스를 사용하는 것임

→ 절대적이지 않음

### 인터페이스

- 배열
  - 다른 컬렉션과 같은 프로토콜을 갖고 있지 않음
  - 단순한 연산의 경우 시간, 공간 모든 면에서 효율적임
  - ArrayList보다 10배 더 빠름
  - 유연성 문제 때문에 배열보다는 다른 컬렉션을 사용하는 편이 낫지만, 프로그램 일부에서 성능이 중요한 경우라면 배열을 사용하는 것도 좋음
- Iterable
- Collection
- List
  - 도착 순서대로 메시지를 처리하는 큐의 경우에는 리스트를 사용해야 함
- Set
  - 순차 열람할 때의 원소 순서가 다음에 순서 열람할 때 보장되지 않음
  - 특정 연산을 위해 컬렉션의 중복 원소를 제거하고 싶은 경우에 사용됨
- SortedSet
  - 순서는 유지되지만 중복 원소가 없는 컬렉션
- Map
  - 키를 중복해서 사용할 수 없지만, 원소 데이터는 중복 사용가능
  - 원소 순서는 보장되지 않음

### 구현

- 구현 클래스를 선택하는 것은 주로 성능과 관련이 있음
- Collection
  - 컬렉션의 크기에 비례해서 연산 시간이 커지는 contains() 이 있음
  - 성능을 측정해 메소드들이 성능을 제약한다면, ArrayList를 HashSet으로 바꾸는 것을 고혀하기
  - 단, 중복 원소들을 제거해도 상관없는지 살펴 봐야됨
- List
  - ArrayList : 원소 접근이 빠르고 원소 추가 및 제거가 느림
  - LinkedList : 원소 접근이 느리지만 원소 추가와 제거는 빠름
  - add(), remove() 를 많이 사용한다면 LinkedList를 사용하는걸 선호

- Set
  - HashSet : 가장 빠르지만 원소간의 순서를 보장하지 않음
  - LinkedHashSet : 원소 간 순서를 삽인된 순서로 보장해주지만 원소 추가 삭제 시 30% 정도 시간이 더 걸림
  - TreeSet : 원소 추가 삭제 시간이 log n(n은 컬렉션의 크기)에 비례해서 커짐
- Map
  - HashMap : 가장 빠르고 단순

### Collections

- 검색
  - indexOf() 연산에 걸리는 시간은 리스트의 크기에 비례
- 정렬
- 수정 불가능한 컬렉션
- 단일 원소 컬렉션 (싱글톤)
- 무원소 컬렉션

### 컬렉션 확장
