---
layout: post
categories: [개발독서, 켄트벡의 구현패턴]
tags: [켄트벡, 구현패턴]
---
- 프로그래밍 이론은 새로운 문제가 발생해도 해결책을 찾을 수 있도록 도와줌
- 동력 → 가치 + 원칙
  - 가치 : 모든 프로그래밍에 적용되는 주제임
    - 프로그램을 잘 짜는 사람은 타인과의 커뮤니케이션을 중시
    - 코드의 과도한 복잡성을 피하면서도 유연성 있는 코드를 작성
  - 원칙 : 항상 중요하지만 때로는 직접 적용하기 어려운 가치, 적용법은 명확하지만 조금은 지엽적인 패턴 사이의 가교 역할을 하는 것
    - 어떤 패턴도 적용할 수 없는 경우나 두개의 패턴 중 하나를 선택해야할 경우 원칙이 좋음
- 패턴 : 지금 당장 무엇을 해야할지를 알려주고, 가치는 패턴을 사용해야 하는 동기를 알려주며 원칙은 동기를 행동으로 어떻게 바꿔줄지 알려줌

### 가치

- 최고의 프로그래머는 프로그램의 확장성을 고려해서 프로그램을 짜지만, 불필요한 요소를 사용하지 않으며, 읽고 이해하기 쉬운 프로그램을 짬
1. 커뮤니케이션
  - 개발자가 코드를 쉽게 이해하고, 수정하고, 사용할 수 있다면, 그 코드는 개발자와 커뮤니케이션을 하고 있다고 이야기할 수 있음
  - 프로그램을 작성할 때 컴퓨터만 고려하기 쉬운데 타인을 고려해서 프로그램을 짜면 여려가지 좋은 점이 있음
    1. 내 코드는 좀더 이해하기 쉽고 깔끔해지며, 더 효율적이 되고 생각은 명확해짐
    2. 새로운 관점에서 코드를 바라보게 되고, 스트레스가 줄어들며, 다른사람도 볼 만한 코드가 만들어짐
  - 켄트벡 : 다른사람을 고려하지 않고 프로그램을 작성하던 나의 습관은 수십 년에 걸쳐 조금씩 바뀌어갔다…

    → 이말을 들어보니 이사람도 그런 시절이 있었고, 자기계발에 의해 습관을 고쳐나간 것에 나도 지금 내 코드가 형편 없지만 고쳐나가면 보기좋은 코드가 자리 잡힐 거라는 희망을 가짐

  - 크누쓰의 글로 쓰는 프로그래밍 : 프로그램을 책처럼 읽을 수 있어야 한다고 주장, 프로그램도 책처럼 줄거리가 있어야 하며 리듬감을 지니고 상큼한 표현 등을 지녀야 한다는 것이다.
  - 소프트웨어 비용의 대부분은 소프트웨어가 개발된 후에 발생
    - 새로운 코드를 짜는 것보다 기존의 코드를 수정하는게 걸리는 시간이 많이 걸림
    - 개발 비용을 줄이기 위해선 커뮤니케이션에 초점을 맞춰서 프로그래밍을 하면 경제적으로 효과가 높음
2. 단순성
  - 동작하는 프로그램을 짧은 시간 내에 개발하는 과정에서 복잡도가 불필요하게 증가는 경우가 많음 → 지금 내 상태.. 너무 공감됨
    - 이런 경우는 나중에 소프트웨어가 제대로 동작하지 않게 되며, 수정도 어려워짐
    - **프로그래밍을 할 때 해야 할 일 중 하나는 지금까지 짜 놓은 코드를 보고 불필요한 부분을 제거하는 것**
  - 단순성은 독자의 수준에 따라 달라짐
    - 좋은 글을 쓰기 위해서 독자의 수준을 고려하며 작성
  - 프로그램을 최대한 단순화하기
  - 의미없는 코드는 모두 제거하기
  - 설계 시에도 과도한 요소는 모두 빼고, 요구 사항을 분석해서 꼭 필요한 사항만을 뽑아내기
  - 과도한 복잡도를 제거하면 코드를 새로운 관점에서 바라볼 수 있음
  - 너무 단순해지면 프로그램을 이해하기 어려워지기 때문에 커뮤니케이션에 집중하는 것이 좋음
3. 유연성
  - 비효율적인 코딩이나 설계를 정당화해주는 가치
  - 프로그램이 발전하는 방향으로 유연해야 함
  - 유연성은 복잡도를 증가 시킴
    - 예를 들면 사용자 설정 옵션을 제공하게 되면, 설정 파일을 사용해야 하고, 프로그램에 여러 옵션을 처리하는 로직이 들어가야 함
  - 단순성은 유연성을 촉진시킴
    - 위의 예에서 옵션 기능을 제거하면 프로그램 수정은 간단해짐
  - 커뮤니케이션을 중시하면 유연성도 좋아짐
    - 많은 사람들이 코드를 짧은 시간에 읽고 이해하고 수정할 수 있다면, 미래에 취할 수 있는 전략의 폭이 넓어짐

### 원칙

- 원칙을 이해하고 있다면, 각 패턴의 세부 내용뿐 아니라 패턴을 사용하는 근본적인 이유에 대해 알 수 있으므로 새로운 상황에 부딪혔을 때 적절히 대처 가능

1. 지역적 변화
  - 코드를 수정할 때 함께 바꿔야 하는 부분을 최소화 하기
    - 안그러면 다른 부분에서 문제를 일으킬때 수정에 대한 비용 커짐
  - 지역적 변화만을 일으키는 코드는 전체를 알 필요 없이 그 부분만 보고 이해가능하기에 커뮤니케이션이 쉽다
2. 최소 중복
  - 코드가 여러 곳에서 반복된다면, 그 중 하나를 바꿀 때 다른 중복된 코드들도 모두 바꿔야 할지 여부를 결정해야 함.
    - 그래서 중복된 코드가 많으면 많을수록 코드 수정이 어려움
  - 병렬 클래스 계층도 중복
    - 프로그램상의 어떤 개념을 수정했을 때 2개 이상의 클래스 계층을 수정해야 한다면, 이러한 수정은 지역적 변화의 원칙을 위배함
    - 이런 경우는 변화가 지역적으로 제한되도록 코드를 재구성하여 코드 품질 향상시킬 수 있음
  - 중복을 없애는 방법
    - 프로그램을 여러 작은 부분, 짧은 구문, 짧은 메소드, 작은 객체, 작은 패키지로 나누는 것 → 예전 클린코드에서도 되도록 잘게 나눠 사용하라고 했었음

      → PS) 중복코드 줄이는 플러그인 있음

3. 로직과 데이터의 결합
  - 데이터와 그 데이터를 처리하는 로직을 밀접하게 가급적 같은 메소드 혹은 같은 객체 내에, 최소한 같은 패키지 내부에 배치하기
  - 프로그램을 수정하는 경우 로직과 데이터를 모두 고쳐야하기 때문에 함께 있다면 수정하더라도 그 영향이 일정 영역에 머물게 됨
4. 대칭성
  - 프로그램에 존재하는 대칭성은 시각적으로 표현할 수 없는 개념적인 대칭성일 경우가 많음
  - 대칭성이 결여된 코드

    ```java
    void process() {
    	input();
    	count++;
    	output();
    }
    ```

  - 대칭성을 고혀해서 코드 수정

    ```java
    void process() {
    	input();
    	incrementCount(); // 위 아래와 같은 메소드를 사용
    	output();
    }
    ```

  - 위에 내용은 input(), output() 메소드의 이름은 메소드의 목적(비즈니스 입장)을 반영하지만
    incrementCount()는 메소드 구현(개발자 입장)을 반영함
  - 대칭성에 따르면 왜 카운트를 증가 시키는지 생각하면서 짜기

    ```java
    void process() {
    	input();
    	tally(); // tally : 일치시키다
    	output();
    }
    ```

  - 위의 프로그램에서는 입력하나 받고 그에 따라 카운터를 증가시켰으므로 메소드의 목적에 따른 이름임
5. 선언적 표현
  - 명령형 프로그래밍 (LISP와 같은 함수형 프로그래밍의 반대 개념 ex) C, Java) 은 강력하고 유연하지만 프로그램을 이해하기 위해서는 수행 흐름을 따라가야됨
  - 머릿속에 컴퓨터의 수행 상태를 생각하면서 제어 흐름과 데이터 흐름을 추적해야 프로그램을 제대로 이해할 수 있음
  - 수행 순서가 중요한 구문이나 조건부 구문이 없는 일반 구분의 경우 선언적 표현을 통해 코드작성하는 것이 이해하기 좋음

   *Junit 의 경우

  - 클래스는 정적 메소드 suite()를 통해 수행할 테스트의 집합을 반환

      ```java
      public static junit.framework.Test suite() {
          Test result = new TestSuite();
            ...
          return result;
      }
      ```

    - suite() 메소드는 단순히 여러 클래스에 흩어져 있는 테스트를 모아줄 뿐임
    - suite() 메소드는 범용이어서, 수행할 테스트를 확인하기 위해 실제 메소드의 내부를 살펴보고 이해해야함

   *Junit4 의 경우

  - 선언적 표현을 사용해서 이 문제를 해결

    ```java
    @RunWith(Suite.class)
    @TestClasses({
    	SimpleTest.class,
    	ComplicatedTest.class
    })
    class AllTests{
    }

    ```

  - TestClasses만 봐도 어떤 테스트가 수행될 지 알 수 있음
  - RunWith를 사용하면  suite() 메소드보다 더 유현한 기능을 제공할 수 있음

1. 변화율
  - 함께 변하는 로직과 데이터를 함께 관리하고, 변화율이 다른 로직과 데이터는 분리
  - 변화율 원칙은 프로그래머가 수정하는 내용에 해당
  - ex) 세금관련 소프트웨어를 작성한다면, 일반 세금 계산 루틴을 특정 년도 세금 계산 루틴과 별도로 구현할 것임,  코드 변화율이 다르기 때문
  - 변화율은 데이터에도 적용됨
  - 어떤 객체에 다른 필드와는 독립적이지만 서로 의존적인 2개의 필드가 있으면 그 두개의 필드는 별도의 도우미 객체에 넣는 편이 낫음

    ```java
    setAmount(int value, String currency) {
    	this.value = value;
    	this.currency = currency;
    }
    ```

  - 위에 걸 이렇게 바꿀수 있음

    ```java
    setAmount(int value, String currency) {
    	this.value = new Money(value, currency);
    }
    ```

  - 조금 더 개선하면
