---
layout: post
categories: [개발독서, 켄트벡의 구현패턴]
tags: [켄트벡, 구현패턴]
---
- 로직 : 하나의 덩어리가 아닌 여러 메소드로 구성
- 같은 기능을 매번 다시 구현하는 것보다는 이전에 사용한 해법을 재사용하는 것이 더 간편하고 생산적임
- 독자는 메소드 이름만으로도 자신이 원하는 정보를 얻을 수 있음
- 프로그램을 메소드로 나누는 데 신경 써야할 요소는 메소드의 크기, 목적, 이름 등이 있음
- 메소드의 수가 너무 적다면, 중복된 구현이 많아지고 유연성이 떨어짐

### 조합 메소드

- 짧은 메소드를 많이 사용하는 것에 대한 주된 반론의 요지는 메소드 호출 때문에 생기는 성능 저하 문제에 관한 것

  → 짧은 메소드의 기준이 모호함..

- 세부사항을 이해하고 싶을 때는 밀접하게 관련된 코드만 모아놓고 관련성이 떨어지는 코드는 분리하는 편이 좋음
- 캔트 벡의 경험상 상대적으로 짧은 메소드 단위로 코드를 구성할 때, 코드 이해가 가장 쉬웠음
- 메소드를 구성할 때는 추측이 아닌 사실에 근거하기

### 의도 제시형 이름

- 메소드 사용자는 메소드 이름을 통해 메소드의 의도를 쉽게 파악할 수 있어야 함
- 이름을 통해서는 메소드의 의도를 전달하고, 그 외의 정보는 다른 방식으로 전달하는 것이 좋음

```java
Customer.linerCustomerSearch(String id)
// ->     정보 + 의도가 담겨져 있음
```

```java
Customer.find(String id)
// -> 찾는다는 의도로만 표현
```

- 메소드 이름은 그 메소드를 호출하는 코드가 표현하려 하는 바에 도움을 줄 수 있도록 지어야 함

### 메소드 가시성

- 가시성을 선택할 때 두가지 비용 고려해야 함
  1. 미래의 유연성
  2. 객체를 사용하는 데 들어가는 비용

### 메소드 객체

- 메소드 객체를 생성하는 순서
  1. 메소드 이름을 따서 클래스 이름을 정함

  ex) complexCalculation() → ComplexCalculator

  1. 메소드에서 사용하는 각 파라미터, 지역변수, 필드에 대해 새로운 객체상의 필드를 생성
  2. 본래 메소드의 파라미터와 메소드에서 사용하는 필드를 파라미터로 취하는 생성자를 만듬
  3. 본래 메소드르 새로운 클래스의 calculate() 라는 메소드로 복사

    ```java
    complexCalculation() {
    	new ComplexCalculator().calculate();
    }
    ```

    ```java
    complexCalculation() {
    	ComplexCalculator calculator = new
    	ComplexCalculator();
    	calculator.calculate();
    	mean = calculator.mean;
      variance = calculator.variance;
    }
    ```

  ### 오버라이드

  ### 오버로드

  - 이 메소드를 사용할 수 있는 다양한 포멧이 존재
  - 같은 메소드 이름에 다른 수의 파라미터를 사용하는 것
  - 메소드 이름뿐만이 아니라 파라미터도 유심히 살펴봐야 함
  - 메소드마다 다른 반환 타입을 사용한다면 코드 읽기가 너무 어려워짐

  ### 메소드 반환 타입

  ### 메소드 주석

  - 코드만으로 분명하지 않은 정보는 주석을 사용해서 전달
  - 단, 주석을 너무 박아도 좋지 않음 → 클린코드 내용

  ### 도우미 메소드

  - 관련도가 떨어지는 세부 구현을 숨기고 메소드 이름을 통해 프로그래머의 의도를 나타냄으로써, 복잡하고 거대한 연산 코드를 좀더 읽기 좋게 하기 위함

  ### 디버그 출력 메소드

  ### 변환

  - 프로그래머의 의도를 명확히 전달하는 것
  - 변환을 가장 효과적으로 표현하기 위해서는 몇가지 기술적 사항 고려
    1. 변환이 얼마나 맣이 필요한지 생각하기
    2. 클래스간의 의존성

### 변환 메소드

### 변환 생성자

### 생성

### 완결 생성자

### 공장 메소드

### 내부 공장

### 컬렉션 접근자 메소드

- 컬렉션 데이터에 의존적인 객체 내부 상태가 유효하지 않게 될 수 있음
- 대부분의 컬렉션 프로토콜을 중복해서 구현하고 있다면, 설계상에 문제가 있을 확률이 높음

### 불린 설정 메소드

### 질의 메소드

- 객체가 프로토콜을 통해 다른 객체의 결정을 도와야 할 경우에는 be 동사나 hava 동사를 사용하기 ex) isVisible() , hasNext()

```java
if (widget.isVisible())
	widget.doSomething();
else
	widget.doSomethingElse();
```

- 경험을 통해(?) 설계를 유연하게 바꾸면, 좀더 읽기 좋은 코드가 탄생할 가능성이 높다.

  → 방법은 안알려주고 경험을 강조하고 계시네..


### 동등성 메소드

### 취득 메소드

### 설정 메소드

### 안전한 복사
